<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023年的总结</title>
      <link href="/2023/12/24/2023/"/>
      <url>/2023/12/24/2023/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>2023年要结束了，是时候和自己展开一场对话了</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p><strong>Q：感觉怎么样？23年的工作</strong></p><p>23年是我毕业后工作上最稳定的一年，这一年我的工作内容基本没有发生大的变化，要知道，在21年22年，我已经换了n条业务线，所以今年我在自己从事的方向有了更多的积累沉淀，也多少能找到发力点，从这个角度上看，工作上还是比较顺心吧。</p><p><strong>Q：最大的收获是什么？</strong></p><p>我觉得最大的收获是思想层面的觉醒，对工作这件事情有了全新的认识，这个觉醒让我做每一件事情都更关注收益，考虑收益，自然也就会思考方法论。在此之前，我根本不知道自己做的任何东西有什么意义，我一直想去做一些有绝对价值的事情，直到今年我才醒悟，大部分工作都没有绝对价值，但是这些没有绝对价值的工作也可以给我带来相对价值，这就够了。</p><p><strong>Q：对今年自己的工作满意吗？</strong></p><p>没有达到我期望的地步，在这里干了快3年了，很多事情我其实已经不太想争取了，并不是摆烂，只是‘争取’这个心态让我很急躁，让我深刻的意识到多大脚穿多大鞋，急不得。所以今年总体看下来是稳中求进，我认真的干好每一件我应该做的事情，思考除此之外我能为团队&#x2F;业务带来什么贡献，我尽力而为，结果如何，我是真的不想争取。不过今年也算是可以，拿了一次m+，也涨了一次薪，还不错。</p><p><strong>Q：工作中有发生一些有趣或者不有趣的事情吗？</strong></p><p>小唐离职了，去了拼多多，不出意外的话，他现在薪资可能已经是我的两倍了吧（苦笑），那段时间其实我也很想跳槽，我一直在急躁和平静中徘徊，我一边觉得我不年轻了，又一边觉得我应该再慢一点。但后来想起来，其实我也没那么羡慕，毕竟工作不是我的全部，我不应该用所有的时间去换钱，我要投资未来，投资下一种可能，而不是all in工作。<br>很多人都离职了，到头来，我居然也算是个老油条了哈哈。</p><p><strong>Q：关于工作，有什么想吐槽的？</strong></p><p>这群人为什么不下班呢？我一直想不明白这件事情，因为我一直觉得如果你的工作需要每天晚上干到11点还干不完，那一定不是工作的问题，而是你的时间管理有问题。今年下半年我每天10点前到公司，给一天的工作留出buffer，再忙碌的工作到晚上9点也就做完了，其他的时间，基本上就是在思考，调研，或者摸鱼。除非9点后有找上门且紧急的工作，或者遇到棘手的问题，或者是ddl，所以正常情况下，我觉得9点半就可以下班了。我也曾经干到11、12点，一两点的情况也有，但不多。但是我们组的娃总是11点下班，所以每当我10点下班的时候，我都十分难堪。<br>如果明年春天我没晋升，我就要被24届的应届生工资倒挂了，我不禁想起我毕业那会，也倒挂过别人，所谓风水轮流转，老天饶过谁。</p><p><strong>Q：对工作还有什么想说的？</strong></p><p>没什么想说的了。</p><h2 id="个人发展"><a href="#个人发展" class="headerlink" title="个人发展"></a>个人发展</h2><p><strong>Q：有什么进展？</strong></p><p>到23年年底，我大概终于确定了自己要长期发展的东西，在21年和22年包括23年我一直在不停的尝试各种东西，比如自媒体，吉他，钢琴，摄影等，经过不停的试错，也算是把这些事情放到了该放的地方。最终我还是决定学习编曲，希望未来自己可以有机会成为一名配乐师。但是其实我深刻的明白，如果我只想写我想写的曲子，那他必然不能成为工作，所以现阶段，编曲最多成为一个副业，至少在未来10年，我不会放弃互联网行业，毕竟这是我的衣食父母。不过有所热爱，很开心。</p><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h2><p><strong>Q：今年社交如何？</strong></p><p>23年其实我是非常open的，open的让我觉得自己不是个I人，但我觉得I人和E人的根本区别在于思考模式，而不是行为模式。<br>认识了活泼可爱的慧子，成熟忧郁的梦洁和激情四射的小熊，参加他们的生日party，家庭聚会，体会到了不一样的世界。<br>认识了年轻的调酒师硕硕，后半年基本每个周末我都会去硕硕的酒吧喝酒，我很喜欢那里，很小很隐蔽，在那里我遇到了很多有意思的客人，93年的大姐姐、在京东上班的party头子、98年的副总裁等等，每个人都有自己的故事，很有趣。很幸运今年找到了一个所谓的老地方，在北京，即便是一个人也会去的老地方，真的很幸运。</p><p>从11月开始，决定暂时退出剧本杀的圈子，首先很费钱，其次我也厌倦了总是去演一个个不属于我的黄粱大梦，想去看看这个世界，过好自己的生活。</p><p>虽然认识了很多人，但是总觉得，自己一直都是一个人，所有人都是过客，我只是在陪每一个人演和每一个人的故事，认识每一个人，都只是在等待每一个人的离开。所以没有人为我停留，我也没有为任何人停留。<br>尽管如此，我还是希望自己可以认识新的朋友，我还是相信总有人能走进我的世界。</p><p><strong>Q：有什么收获吗？</strong></p><p>喝酒这一块，喝出了点自己的心得，也不算是心得吧，有了自己喜欢喝的类型，比如硕硕的限定款李子酒就是我的心头爱，威士忌的话喝过最好喝的是艾雷岛的雪莉桶10年，最近的话喝红酒喝的比较多，博若莱、勃艮第、奔富407，感觉酒也有不同性格呢，不同的心情和环境就得喝不同的酒。</p><p>好像再没什么收获了，收获了开心？毕竟社交嘛，除了隐藏的1%的人脉资源外，其余的都只是为了填充无聊的生活而已。</p><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p><strong>Q：今年有谈恋爱吗？</strong></p><p>谈了一段，16天，其中10天还是异地，很抽象，我觉得两个人爱上的都只是自己的幻想，好歹最后是想明白了，所以也不痛不痒。<br>除此之外，今年还发生了一些其他的事情，比如前女友的闺蜜和我气势汹汹的表白了，这让我感到十分诧异，因为我和她也算是将近8年的老友了，怎么就和我表白了呢？再加上她还在读书，又是异地，所以我拒绝了她，我很抱歉。失去一个老友我很难过，真的很难过，但是我又没法做什么，所以就这样吧。<br>然后就是夏天，前女友想和我复合，我也感到很诧异。<br>然后秋天遇到了洋洋，想方设法的认识了我，然后半个月后和她前女友复合了。</p><p>这个世界真奇妙，这都哪到哪啊？</p><p><strong>Q：如何看待今年自己的感情经历？</strong></p><p>我觉得我真的想不明白这个事情，我总是想谈恋爱，但是一个人的生活真的很好，一个人逛街吃饭看电影，哪怕一个人去急诊，也就那样吧。我忘不掉22年分手后持续了半年的生理和心理戒断反应，太痛苦了，当走出来后，剩下的就只有观望了吧。我想吗？我很想，但也没那么想。<br>所以我不知道该如何回应别的女孩对我的喜欢，我也不知道该如何面对自己对别人的心动，更不知道如何从自己的世界走出去。所以我根本不会开始，爱是自由意志的沉沦，我体验过一次，我勇敢的面对了，我希望未来自己可以再次有勇气去面对一段新的感情。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>帮兄弟找到了对象，于是他果断抛弃了我（bushi</li><li>公司组织了三亚团建，我第一次知道原来休假可以什么都不用干</li><li>佳佳来北京找我玩了哈哈，她真的很暖哦</li><li>美好的记忆都在寒冷的日子里，阳光明媚的时候基本在上班</li><li>5月去威海差点冻死，10月回家穿着羽绒服差点冻死</li><li>兄弟女朋友对我说喜欢，差点没把我吓死</li><li>打过的最好的密室：弥生2</li><li>下定决心花一万多和一个我认可的老师学习音乐</li><li>读了很多本书，村上春树的长篇大部分都读过了，我很喜欢哦</li><li>今年开始听r&amp;b了</li><li>大晚上一个人跑去急诊看病，我很厉害哦</li><li>今年钢琴终于不吃灰了，还买了个midi键盘，吉他反而弹的少了</li><li>小五又长大了一岁</li><li>我终于又自己的小网站了</li></ul><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul><li>工作上升职加薪，不能升职加薪的话，99%会跳槽&#x2F;活水</li><li>完成副业的第一笔入账，编曲尝试做商单</li><li>努力学习编曲，线下发展编曲的人脉</li><li>保持读书</li><li>如果有可能的话，爱上一个具体的女孩</li><li>好好活着</li><li>有没有可能安排时间锻炼身体呢？</li><li>去看看更大的世界</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，23年是幸福的一年，自己也没犯大错，我也在经历着自己应该经历的一切，挺好的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pnpm工作原理</title>
      <link href="/2023/11/21/pnpm/"/>
      <url>/2023/11/21/pnpm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>网上对于pnpm原理的文章比较多，并且官网也写的很清楚，但其实很多开发者对这方面比较含糊不清，所以今天我来捋一下。</p><h3 id="非扁平的-node-modules-目录"><a href="#非扁平的-node-modules-目录" class="headerlink" title="非扁平的 node_modules 目录"></a>非扁平的 node_modules 目录</h3><p>在npm4的版本里，使用了扁平化的node_modules目录，虽然比起之前快了不少，但也产生了很多新的问题。</p><ul><li>幻影依赖</li><li>扁平化的算法很复杂</li><li>一些包必须复制到一个项目的 node_module 文件夹中</li></ul><p>pnpm巧妙的使用了硬连接和软连接解决了这些问题。</p><h3 id="硬连接和软连接"><a href="#硬连接和软连接" class="headerlink" title="硬连接和软连接"></a>硬连接和软连接</h3><h4 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h4><ul><li>具有相同inode节点号的多个文件互为硬链接文件</li><li>删除硬链接文件或者删除源文件任意之一，文件实体并未被删除</li><li>只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除</li></ul><h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><ul><li>软链接类似windows系统的快捷方式</li><li>软链接里面存放的是源文件的路径，指向源文件</li><li>删除源文件，软链接依然存在，但无法访问源文件内容</li></ul><h3 id="pnpm核心"><a href="#pnpm核心" class="headerlink" title="pnpm核心"></a>pnpm核心</h3><p><img src="/images/pnpm/1.jpeg"></p><p>这张图非常清晰的解释了pnpm是如何处理依赖的</p><ul><li>所有 npm 包都安装在全局目录 ~&#x2F;.pnpm-store&#x2F;v3&#x2F;files 下，同一版本的包仅存储一份内容，甚至不同版本的包也仅存储 diff 内容</li><li>每个项目的 node_modules 下有 .pnpm 目录以打平结构管理每个版本包的源码内容，以硬链接方式指向 pnpm-store 中的文件地址。</li><li>每个项目 node_modules 下安装的包结构为树状，符合 node 就近查找规则，以软链接方式将内容指向 node_modules&#x2F;.pnpm 中的包</li></ul><p>所以每个包都要经过3层寻址：</p><ol><li>node_modules&#x2F;package-a</li><li>软链接 node_modules&#x2F;.pnpm&#x2F;<a href="mailto:&#x70;&#x61;&#x63;&#x6b;&#97;&#x67;&#101;&#45;&#x61;&#64;&#49;&#46;&#x30;&#x2e;&#48;">&#x70;&#x61;&#x63;&#x6b;&#97;&#x67;&#101;&#45;&#x61;&#64;&#49;&#46;&#x30;&#x2e;&#48;</a>&#x2F;node_modules&#x2F;package-a</li><li>硬链接 ~&#x2F;.pnpm-store&#x2F;v3&#x2F;files&#x2F;00&#x2F;xxxxxx</li></ol><p><strong>清晰的知道pnpm寻址步骤非常重要，可以有效的帮助我们理解pnpm的优势。</strong></p><h3 id="幻影依赖"><a href="#幻影依赖" class="headerlink" title="幻影依赖"></a>幻影依赖</h3><p>在npm3的版本，由于所有依赖都是在node_modules中被扁平化的，而包的寻址也是直接在node_modules下找的，所以会出现幻影依赖。<br><strong>简单的说，幻影依赖就是使用了一个未在package.json中声明的包，但由于该包是其他包的依赖，所以因为也在node_modules中，所以并未报错。</strong>幻影依赖会导致一些致命的问题</p><ul><li>未声明的包，在卸载依赖他的包后就无法正常使用</li><li>未声明的包在更新后，如果出现breaking change，则会报错，且问题难以排查</li><li>依赖不清晰，难以管理</li></ul><p>使用pnpm可以有效解决这个问题<br>回顾上面的3层寻址就会发现，在第一步的时候，如果使用了未声明的包，就会直接卡住，因为node_modules下根本没有这个包，所以幻影依赖的问题就被解决了。</p><h3 id="节约空间"><a href="#节约空间" class="headerlink" title="节约空间"></a>节约空间</h3><p>pnpm巧妙的使用软连接的方式代替了copy，避免了重复依赖的安装，相比 npm@3 将包打平的设计，软链接可以保持包结构的稳定，同时用文件指针解决重复占用硬盘空间的问题。</p><p>存在硬盘的文件并不是普通的 NPM 包源码，而是一个哈希文件，这种文件组织方式叫做 content-addressable（基于内容的寻址）。<br>简单来说，基于内容的寻址比基于文件名寻址的好处是，即便包版本升级了，也仅需存储改动 Diff，而不需要存储新版本的完整文件内容，在版本管理上进一步节约了存储空间。</p><h3 id="快"><a href="#快" class="headerlink" title="快"></a>快</h3><p>最后就是快，对于已经安装过的npm包就不需要第二次下载了，即便是离线状态也能完成安装。再加上不需要重复安装依赖，灵活使用软链，所以pnpm是真的快。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈一谈工作中常见的代理</title>
      <link href="/2023/11/14/proxy/"/>
      <url>/2023/11/14/proxy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>日常开发调试时，我们通常会有两个本地开发的方式：</p><ul><li>使用webpack等构建工具提供的proxy，或代理工具，把请求转发到目标服务器上（可以理解为Remote）</li><li>使用代理工具，把服务器的静态资源转发到本地端口（可以理解为Rewrite）</li></ul><h3 id="Remote-or-Rewrite"><a href="#Remote-or-Rewrite" class="headerlink" title="Remote or Rewrite"></a>Remote or Rewrite</h3><p>而具体哪一种更好，我个人觉得还是得分场景看。<br>通常情况下，如果你的开发协同模式是一边开发一边联调，server每次把代码推到他的服务器上，那使用remote显然是更好的选择。<br>但如果联调方式是同时部署在测试环境或者线上小流量时，remote和rewrite就都可以。</p><p>我个人更倾向于使用rewrite，不仅是因为我在工作协同中基本上都是使用线上域名小流量调试，主要我觉得<strong>rewrite可以做到无成本与工程解耦</strong>，对于任何项目，我都可以使用rewrite快速开发，而不是考虑工程环境的影响。</p><p>在实际工作中，<strong>我们团队的最佳实践还是使用Rewrite</strong>，我很少看到有项目在使用本地域名开发，不管是使用第三方工具，还是框架内置的代理工具。</p><h3 id="how-rewrite"><a href="#how-rewrite" class="headerlink" title="how rewrite"></a>how rewrite</h3><p>Remote这里就不多说了，基本上所有构建工具开启的方式都大差不差。这里主要说一下rewrite，因为我发现在实际工作中，其实大部分开发者都不需要配置这些东西，需要自己配置时，一般就去问别人或者各种搜，出了问题也是一脸懵逼。</p><p>其实rewrite很简单，举个例子就明白了，我的线上连接是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//blog.ayulove.life/</span></span><br></pre></td></tr></table></figure><p>我的本地服务器是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:4000/</span></span><br></pre></td></tr></table></figure><p>现在我需要通过代理工具把线上域名打到本地，我只需要写一行正则就可以搞定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//blog.ayulove.life/(.*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// replace</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:4000/$1</span></span><br></pre></td></tr></table></figure><p>很简单吧，其实这就是rewrite的基本操作，也是核心思路，但实际工作中的路由远没有这么简单，我们再看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//test.com/moor/app/m/look.html?a=1 // 线上url</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:4000/moor/app/m/look.html?a=1 // 本地服务器</span></span><br><span class="line"></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//test.com([^\.]+\..*) // match</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:4000$1 //replace</span></span><br></pre></td></tr></table></figure><p>在这个case里，由于路由变得复杂起来了，<strong>我们需要写一个通用的规则把服务器的静态资源打到本地</strong>，所以这里写了这样一个正则<code>([^\.]+\..*)</code>，我们解析一下这个正则：</p><ul><li><code>[^\.]+</code>：匹配一个或多个非句点字符。方括号内的 ^ 表示取反，. 表示匹配句点字符（. 的转义），所以 [^.]+ 表示匹配除句点之外的任意字符一次或多次。</li><li><code>\.</code>：匹配句点字符。</li><li><code>.*</code>：匹配零个或多个任意字符。</li></ul><p>这样看起来似乎可以了，但还不够，<strong>在生产环境中线上路由和本地路由很少一致，所以我们要针对前端路由再写一条正则</strong><br>还是上面的例子，现在我改一下本地服务器路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:4000/look/index.html?a=1 // 本地服务器</span></span><br></pre></td></tr></table></figure><p>那上面一条正则就不够使了，我们需要再加一条</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//test.com/moor/app/m/(.*)\.html(.*) // match</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:4000/$1/index.html$2 // replace</span></span><br></pre></td></tr></table></figure><p>这样就可以了，<strong>我们使用正则中的捕获，在replace中反向引用</strong>，完成了我们想要的代理。<br>到这里，其实我们就应该已经很清晰了，所谓rewrite就是利用正则去匹配路由，然后代理到自己的服务器上，无非就是因为路由不一样，写的正则不一样而已，其实并没什么东西。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions">正则表达式看这里</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>代理这种东西需要case by case去看，不同场景下匹配规则不一致，重要的是我们要知道原理是什么，写的每一行命令有什么用，才不会导致我们遇到问题时不知所措。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给洋洋的信</title>
      <link href="/2023/11/12/tina/"/>
      <url>/2023/11/12/tina/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ed2e35c8ad0e8bdaec8ef28ab7939814a934790a4e019a7ddedafd65fafb6dcf">4630436162ade97ba2718b7d0c4b3b630ef8b034c35893a7afa4c54a5752d90eba191a593f89497fdfca691efaf72d5caa0c664d8e7a85bd833fac72ade59ddbf66b4bdec75a2ed1e83f57bcb279b78cfc65fbc18f7606dbec4f8a0cfd661414c92c100d2773e693a5c8b2ccac7fa14accc64f83b5b264a4d5fdf6bd69eaa8f482afd099013e76ff4e51aba738e821baa622005a4c66f56ab33cf2343fe1cf2e0172f93bd31fce364b9080e27185a46d57dfee48fa7acad956c60072fcdef615172cb1bc7e001573317575587dc894bce886edcd55082bdd6cd35662d9dc16b455d8de94f0f748281ebc2f8fa61b6e163bb39f97ace0f687580a08ac82e3d87b3cc4a860bcf9f4cac4016a5fa2510665cf62bfb02d13da9ca02935718c0bd99bcde7e939c5f470fc5adb994dbe109a89cfdea4caa3510b9781c1fb75ae7b1fc36a7233dd9e35157b43f15b8b678d2c77e0227630af0b901c73f8ac3d63abf31f4950726b0ebaae2f5e4954203a19b09f15dc5d41ac5b92e52ede050fdce3b7dba6c16d3f37020f1f44eae6f005b8a1213063df070c9ea10d347cb0c1b53955eee60b0243c94f2cd2440e81dbb46512793aa075bdc0b5b19ca97d67b64ced2f8f86cc30f935afc2b4e39c5080e2b653e62a1fd1347544f1f757bc13c7c2a9ce72c88aaa8bc28ddc396788c041dad411a524921a9782f73910c969f05bd1ddbd5b0edf7679b188b1ea63f3640fe0347d011655518b59d64fecb4fe3053597ba228675b77edddb796af10c16d876dbbcce4ca3f30f2c224f606fe83783db7a00f50b306d937c76a051a1ba29a7773936187e7198abf4c6f10c830d93422ba573003194cb2a2bcb68e9b579879517c94c55ef5efa16c639acd28590b6407b3820f614bf627f68a9ef0fb296ff3011c3ebaa7089fe216dff9f2e211b402f4b6981d82918bf4974ffda60d48d5f231ec366e0b2c1d754aa3dc5b96f5139c72b31c6061859eb6898b46b423c17da3392f6305eb8465c74220b248b0748c8e29e1819f6cb3487a319f665cefe952588f9270c2fb675754a2be272293df51e7a25aaa6f36eb23ff823da1b2f7e8748443a3f8cd98154b4379844e9d4e9cc1999ab8b75446b307a2e99d425f44edf23eb1247713e930d5a210ee420078d2fe8bab7fc452ceff062c6c1bd771dd3661a83ead75589f3418deed4a96bd896dd3592d27e8421324e02c908ae31ea2df350da9fa8bc606d09fe9e30d9d7fafed22093b54800fb4f1ff5c215b6d204e80cb255ee68ca4e842c19830f88148b95e27e4517bdfd2b56dea76f7efb9b2d91213ca9563b1faf582d52170ceaafdf1444d28fa07c62cc24033b3dd378f1afa40755a31f25dc1e29570011fac32fc6add8d243b9342bf1e77f26b1962446c21b3f3132bdfb29e28d23e93dabd886bcd129d5d6ff59a649d0225890a53dbe2c454b85a2cb1824d8be62ff609df4ce903de79a98d100ce431aad44089c0ee7833f792381f9c647780dca233ca8398288624b46ecb28c77db40894b8f88254148cdc3342d8ad11a02556b293d18d2d856958c59f55ce791f13524a699adcb00dc31aa28c67ad8703bad3f25750e188756c17ee1415aaf288ada621d3247d4c9cc3e13915dbbc208fa3936c6f5ac9b0a9b688e18ed0a3872db9eabc2fc72eff2cd4241048708090cad0d1655a5d2af49f1f2dad844bf3b3e548fe906152cace3ea246fac86dd5e5ddab045e968f3dc09a2f43483541e2b3487a3b05282d7c050bf7ad13696932ce0260ad3d32868205b484f1bd043523bdf3c4f5cb3075c53a3a9fdb59ea3455a227c08cb74e0da09895243cd7a3824992f64fe56bb1d64ef6a348c2c6712356dc6b70c31c4f1025029d9c0c298d2f931925e993e2c62fb8f0ea2b2d11f83e6aa7f3cdc333ac8c868ae7f815b7c72dea9bc9fe09d9e4bf8681d7107057f9130b2a448c0bc39f05baa47df827050a367aa22a4e165c3a827cd625a5416fb175613c8fa922dbac6eae2fedf27eaa1045cae3b48a2fd5d3e37f6ebdd77c8f606a223b7edd84e4cae5149aff02b2510311b508a05360149011af67c63be5ba99403aef08b5723649ea7e4b1f7327e08100bc74724df4c808f95d37dfd8b2111a3c29b34e5d9f77e1cc870c5d9dc193b9657782dba8943110158b82632a30bb3cac75e63b046d51077a4e698f6bfddbf56558611de3d2f6a2d97b7e8bfc3013f0f3ab267c874af9e7a4f3fde3fe1851ba7c538b7fef44f7d2c1be0ed349398f487340790084794e4f267d530df39c9d3750c9442ebee1680e62a3776248dcd5bc415129a62f59e7901fbbe197bff9804308988f3ff7d90e960f1ac0f1a2243eb38e09b00b38365224e90e0a25645fb363981699adedc193d814bc027395c03ff096458db288e62fe47e85e1f1629f42487bcaa9daf6fc82c0a619026c6f917b2d20aaead5274699282f9c792a2e7562a676ef2b183c3c46a4e7f7378093f54baa6e391f80f0cec940f6c7d7be5831f9644812987ea69b37770fe89f25fa101c302c5c246749c237a439932c259062bf29e7bbefda22579b77c789d779c98362b6ee608effb2d89023e95acc77bdf3b412077b4d6706a601aa10018b70a1e81cf0899646dc16600d3045b178cbaffa06336ed02e923afe3d02d577658906088b9a980a1ab43fb44ebafd62f9215116486b4cc58b92c3b0a683470202d982729d40a3599178e36bea2be33ce805fc9dff1a0e06478db31e90c8ea71cfe87aedea859df54e5c6611e1c47f2c6a44f1876406ef55507bad60a64fbdb5257c7cb02e81c305937d6d21c00ea333ef0b5c693e7c53b4f5d8325fe5c68e8d967161e78c173ebf80b1ccb3907bb61c8fc2db0821f8681dd16348d8e213b2fd1cfee662a3750568fe64d140fb50892dc1a4286a66674842b0cd513d98d860944c1b22ea4f5b049a0fa37af3ac732acaf70c295c4d268af3662ad7d18307562ddcca3b28cfe8ea2b7d7d195407411e52e471459b4b1e1955f770b19c64ca72650fc28cee689a27f4b2154953f7744a4399cf1ddd8ff9eb1a729306d9eb2d71be6760ca2d7ff874e4558d0532166bbf27783f10bc544cfb00c4d70feafdd12b132fdd08c7a49421bcf5dae5b6334aea89b81a6775836ac21e9c0a5b0f1bb5e494893a91ccf5031d7040b518075b7ce0a168befb7c58ac60e2dc7b8b714d99b5e6be08f778f343f9c4107155cdfb19e23f23e7d092649ce2d48ff2726da0a62829fe3457419439df2e29d47b06bc12b923f6f164bd4598724342eb866dd1afad7960fa7f344102b53abcd04e90a468541fc1a836bbd85791008d352c0fa7e3ee0c55d806d13a621b3e3cb4080d07441ef18fe5b156d1cd2b861cd1374e60e26c84df63d438f18039e9aca4355b09e048cc5f6779d6a9de094f1568f2d1c5f49ff6ab6cdb345172168c7a0883e571b9935b103de4af119c967aab390d1fe7f8b4fe9f3cc653de4addffc06b1c8de1ccdd2d42309c0ca9529ec2096005c6b4462086918a7df83f8f6b32cbca434c79fa02838a497747888bd33b9bb2dff82d8bd872369e5dfb817c07d924492c8bc07cb9e1fd1e970c18e6a1d12f92b5f4019613a2157d79c2d3d5b2ca321a680d9f85efd57eec6e4223fe3f0e70a96c448ef2955b96ff57bb5bb132dc7e4a858c26f31b165347ece08e5c864aed723db026d5e1324ab019b0af924c5d331d99b4ba51edbb7ff88027149976f5ec40cd5149ee47427494694ef4b2522386b38d8a93d1ff1293f6d047c81d9c337a8063734660a5766ff795bb6434c27c41f6c9bca2974d14d4076dfa3660e87e8192cd260d9bf0737fa3cd1d029abf32168a6e2b5cb71e7e89bd6c97720626a1335611fa8abf32f23ab9ed8878a030df284e1afa543683964c69c49c8d9c11d60bf3e0b37346d4381a88e8be57ff98053791f35731f6ad7247b66ccdd5e7ac20f5c0f4da28408f86d3ec14a111924ceb737340667b6dbf61bf3994bbcd0f2afc3ca1dd65a73eca45fa4c630e047c1b26ecd40a318a50fbaf5a5ae3e382632bb6d2d1beb3e308be3d1ffc1c7f6c1600a1a907264fdd1b20b0f569ef2d3de356fbecd50d7ea484d6d598ad9879f7a32184559380dc2ab9c17aa0b7091efd897bb7e31b88a46fd4061b96fbe4b87aa15da4e09db97b8c9e91f9455073df6684debe934e266845d7b228eaf11a829d462c2d107e879a0de4e9d65bd8d69c7316e075fa4b227ff3cd21d4eff00cfcc777e91820f2672f6509844cc29ba840ae9483b729d8e8b0547ae2a3cb6164c6269d52aa985adc64afaa953ef4eddb35794671a589be4ad3fb1d61e93af74a102926c899713142aa3f7226ec19715d63cefe66850cca52179d8994e58f3f30aa91d453a1c07e6e22db9e0c016314fd8d4e165adb0685b48f98e4585f17b821cbffe86fa203cc2aca546aba67452bed936a1719b1546790f3eb1e01199d89d7ce2954aa6b36d6fc4ece1baaf3e0ff3c7cabbf9721f5fe750a0f7ffa4ee2df3780db476524b08d703b9b97f33f1c28ea1d6948a09b315a942f1194f97069d250c7867ca521f53406bb9b26ebc5f181fafaf402042047da8b35a42db902ae3eb69862efc6e217a0a2f153a7d2bfda11d770cd29c5e27ea4526bf91147ff9e7838799464e3fcba2af65b0020de7d09f2d77965b7b16f615281b96fa8f281b24a5a51af8f16a0a9c60b6cef6ae37acf20bb4b5d9fab0452032f810b37bc263d7f85c25a81981dc3af055fc63c8661badc9fbcfc2010215529c8ccc8038a544191e1bd6dab98a4c02e7dab927d793fceb8512e6e182177b977326f04b387944fd9af31f74ef60770b440a2b325af7b60aad86415d99beac2515eb2eb72e5302b3f3edfe5240ca30b07c5032af791afacab145e5a8d7d6907635fd84cb0cd7b64eb15c7a976cd688b46ce5cc28121c0535113e6a03b5c8de1402dec5d4354ed56126ff961296dbdc282a1ac11222c6998c9eeb982439206c2f884d1b324c1749b281252369549a54325ce0a9ec5ff034e5a9c73dd2cc57b275e11c5fd5828bf2f320ed489b513086ec596929e4bfc0bd424c8fec437dadba285b84712a7d269d9e0bc873ef2846f598d4673d06a0b8c2b4b8b6c742bd549fbadcbdf53aa8d7174e5d3d43c07b224afd5a83a3a0fd4a3de7e2ce251e91d3e6711937bfd906f77ce3d072aea3c61b3b2991de937dddec60bbed3da1c415cbc644441dccc4bb35704be428866ce9e239a93133d63533b61d599116c4e02a782031f82cbbee9565729b3ee8c74d2e067270dac0d7cda088dc870481fe81c44a37aa35ff7a754aab099084017ed06d606ad1d65c3a45515a9e0068db65f38163c216d75795489ff749d6a02db713798093cec812ed7ba266578259f240c13c8117710c701926f2c8bf04495a9bbfab51ab37c462a8c65d22ed92a8dff2de744882c7605823e0b69d20e4e7091ec09078e014330c017d2a0a6fc29ebea533e92cb654f5be494171834bfff013b51f2825a29ef68cdf78903c88cffd37a30fc85fd867546a6487f26df0e37c882823b41858c727e5cfa3a2a27024727dafe115e45903064ea6fdca1b0d3b5d13fa3578c3ffa338aa77d06c9fffe9619ceb8d606e54d2adc6d5269800d93343a38ab6d58abfcee3881d718a5c93a70a869059f952bfa247a98c235ad3192a598dad36edf671dbc22d008daba20c4f092aea976016ddea079e405003f63ada9b3f5b4d0f08d25105148f71de9602a3848697e04235be1f2480d56b9e22dd69fa885d35e06008b54cbdeb704c2803e170f5ec6b399c373174cfbf33b3713a1368a379e168baab06a33424b726ed9c104384d03d07d20bde20b82b9bff50c5ccc76bbf964729ae26f5826d4ca92cf975a2b24a42cdcb128b0be7a0c89fb8c667bf037699a14da93c0e63eca1799e9105fc7f94f1e0957e5b9d393b175105602eb986e27db801dea6af32b921cb0de07097cb1f27b9427b9f2fe2b20eb812d9226933249f57fb698d2dac599607ddbbb46b1a66523eb2590827b0a9f98d95a3e9379a12bbe2b350166dbd2fdcb98ba02982110b010b9a67b3c82ce9c7fe71cb44607748e4f819d7b21dccaf44f351165d90e889f2d7665c29cf98a24340c74d6632d5a4962d8e62fc98e1eac39a69a24866fe62ccca9e024d95ae806a4fe5ca11b6c488e8c6a3bfddd4316ce075e96c0986e89b4db187c958908a65017f418398d90468905c6f112d4ef8c7c7016bd7655fa601c79fa839a66a05c71861981d91c3c883530eddb2d55d1541003769d312ed5245574cb5c8de3da38d99889aeb6d8e976424a2e421f596aaf108002915a85a8c2ff91325dfb7e3a33e73665664aa12ed17cf4f3a48278e4faa2bda8bd06f33d3cf7a6dc6f3fc348b3057a3c17cdbb3e84981f51b1c4ed609881ac90748797e4e3216bcebc3f4a658413094388cdaab9f4a67c4d1c390daf7a70bacab1126b9037fd088c139ac17260c10a403a38a6742c382587501972d6b85b2f756a95d86a990fe3afbae07557fad670668e50fc06372865b63bb014f1108cdbd2ed2cc86d2058c30e38e03b7922009b5b344e113d2299fdda507735f41be3f099353973522344e0ce08e2cc106de5fa0bac9e052e6a600db510c0ce122a73b3a9898923661fc336f3f4712daa985892da6edab0a09b1acd3464a45ae87264d1c0e63b600e65556ef1b8b7b969ef89ee0ad0b24355719979527fb95b350ae7fa38f17782805461a49e716bf8a20fc606bd9c9ee57b7b56305a8b4e614a3cdefb6e67fe22ba88c1dfb90b3b55378213f373d1ec93852b6eb7e398ee79fd31cd24acfbfb0402c3f2e95a3f64964de20fab5da5eda10a0df62d2582eee8143a5cf8d8942518020527467cf5983090ce77e86193984e2a8d8c927317f6b5ac1e8df7a68b63fac2f6f64dde4dd1367d28c58ac1db07cc5346909f59b6caef6064662213d1febda3e4023764ffffa8a2e017d97a60140ab4a45fc9d09356c8e0d2004cb81bb59e482e3e0df2800939a278b039e34dd68a851301ceb5b8ebac455513802fc08ec47c7c4aa40c6563eab0285120bc30306c6396fce96fd22b3cb78fd31a74ff8694e1de0c8f27fb26c83c755e8487a27d92fb5952c868f9869a617d56d858bfd874e942438e95e7c4a6cb93a097ecb8c9fc8a6ca43626babaa942816d772c29d3f27e6bb00f1ef1e1f649b37aed857d81e4ad28ce3b5565ec4ec1d3c63070d11da549100eef5a8e552b3460bebb786a2a0b90f9857299d9cd0a7f3ba0765c0d35d701ef0e40fac91c3bcd6e0e63cac8edaa01d46504e4c7c8001c1ce1cef7a49c84c2d2d13c89c539cb7c5541e7841afabebccf2c68d52fe484c0fd8624250661feebff84eb09d05557135975c7f297325d427166cd80280d5ff384e837bdd995da9a296e64efc58ae2a9f1efaf3b5bd63ded2f08c66a9c410771ab388056d6ada2c19e93be0e99615898da3bd4f0833ba925168976fe7c289c94be27ec1ba02dcb21e5bdb9b4d459e001d168e48e8721b0db3de6a3863677669c561aa3ae02121bb2d4b7bd34f71bcea6867b8f5d3a18709f828c6347870a251dde8861c09d5ac787db0000aac2dc71079d419675d771696ab3c1e9396717a5a0efdb7d369dc54e00e34d623754bba0254dd0c29b7de9b7de3235507897e4e3585338f9a513e5d41eae41d233551a88f71542ef6b8e168874e71d92b74253413e2e18f37af814abcd491ef346ae3906ee07f7593d7aa5193446f86f25e3edef95cc3ad5c7d413ddfdf7da11c07c27fba6448d9f2dbe54bbaa61ebb24d343305ac8f5769c78cf669311db07a49bf948c189d1f224acc8a03387d4201bc0cb6967af0dcd63106e8fe8b1607788ec451e9bba8331fdb3358bf14a959905cd79d9239087111d03f246b884b119d4935aaeffa9f88b15de78a319b715ca8f538d13adeee1e1c2aa17ee5a8fe11b92d5ec2768561ecd7fbe72a783dbb1d3c85da37a4b9e784c7b45514560d702865108d35c9728085a9547801abc656329348c7d3c0f2f36633027c61f692488986f62facf8b88bb537b8ed69857df637b8b0c50dbc8502e303d03aeb6ac35991a2ae85e468dd267441b001b6f8525404c9c56eeb6b7814e41460b717d32e8185c3766b35225c2a7aae801fd8f38de1b7806cf23c4c3e75b65c76b86ca046c6c1bc7ec82e321acfb402da0e129e03f7bd168c5ae02592d5b5ddbc1f55447858ecc35b4504d786b1f28b983507e7c548f3d2f2bc9f7d5440191fe44b7e33cec4edb1873630bf1e1bce2110890eccf4bba11e6d9900998b8f8102de10ad02a0b99e93161022f099ab43aaf1e9a71da07e6b6f016b57de2f13fad9f8292b679880a6e19a96f14f81f9461aec9909e1f5fcb19853cf0670856d034b95f06b2e607459443593e51a44e2ff9d2fc341aafa352b651a8684dba41c8396901615ef4e354f2a2dbdcc5cb16159788efb3bbe06aba138bf9f3242e8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">请输入密码查看.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次C端性能优化总结</title>
      <link href="/2023/11/08/optimize/"/>
      <url>/2023/11/08/optimize/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>如果说b端比较重要的东西是核心链路的打通，那c端应该是最看重交互体验相关了。<br>半年前我们上线了一款新的项目，是一个端内h5。随着该项目的渗透率不断提升，保证线上稳定性和保证用户体验就是最重要的事情。<br>根据监控我们发现该页面的体验似乎并不是那么好，这里指首屏速度，直观的感受就是有明显的卡顿。</p><p>虽然我们对接口进行了优化，但整体看下来，页面的首屏速度还是不够快，这将影响用户对于我们产品的认知，也会影响到回访率、留资率等核心指标。<br>所以我们必须要用前端的手段进一步优化。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在做任何优化前，我们都应该先了解现状，了解现状需要通过指标衡量，在这个case中，由于框架层面已经提供了传统的优化手段，所以我们使用传统的浏览器性能指标就可以满足诉求。</p><p>在传统的浏览器性能指标中，FCP通常会被用作分析页面首屏速度</p><blockquote><p>FCP (First Contentful Paint) 为首次有内容渲染的时间点，在性能统计指标中，从用户开始访问 Web 页面的时间点到 FCP 的时间点这段时间可以被视为 无内容时间，也就是说在用户访问 Web 网页的过程中，FCP 时间点之前，用户看到的都是没有任何实际内容的屏幕，用户在这个阶段获取不到任何有用的信息。</p></blockquote><p>所以通常会反映页面的首次出现内容的时间，而首次出现内容时间会反映当前 Web 页面的网络加载性能情况、页面 DOM 结构复杂度情况、inline script 的执行效率的情况，当所有的阶段性能做的非常好的情况下，首次出现内容的时间就会越短，用户等待的时间就会越短，流失的概率就会降低</p><p>我们分别分析了pct75分位、pct90分位和99分位的fcp</p><p><img src="/images/optimize/fcp.jpeg"></p><p>我们发现大部分用户的FCP停留在2000ms左右，个别用户则是8000-9000ms，为了保证大部分用户的交互体验，我们决定使用pct75分位fcp作为性能衡量标准。</p><p>实际上，这个页面我们使用了全屏的骨架屏，但这个骨架屏并不能触发fcp，对于该指标，”内容”指的是文本、图像、<code>&lt;svg&gt;</code>元素或非白色的<code>&lt;canvas&gt;</code>元素。<br>所以骨架屏只是一个进阶版的loading，对fcp这种性能指标并无收益，我们需要其他方案。</p><h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p>有了具体的性能指标，我们就可以针对该指标制定方案，由于这是一个端内的页面，并没有端外的强诉求，所以结合环境，我找到了以下几种方案</p><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><blockquote><p>用户首次进入页面时，将应用渲染根节点（一般为 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>） 下的 DOM 内容保存到端内，用户再次打开页面后，客户端会在浏览器加载 HTML 之前，将之前替换为上一次保存的 HTML，最终浏览器在解析与渲染页面时，就可以立即加载出更丰富的 DOM 内容片段。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>如果命中snapshot，fcp会有较大的提升</li><li>接入成本较低</li><li>维护成本较低</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>依赖端内SDK</li><li>无法封装成统一的SDK，不同case需要按场景接入</li></ul><h2 id="NSR"><a href="#NSR" class="headerlink" title="NSR"></a>NSR</h2><blockquote><p>一个 React 项目的渲染实际还经历了「Evaluate Script -&gt; Data Fetching -&gt; Render（Create V-DOM &#x2F; V-DOM Diff） -&gt; Commit -&gt; DOM」 的漫长过程，为了避免这部分耗时，可以封装一个SDK提前渲染好页面的 HTML Markup。</p></blockquote><p>简单的说，就是在上一个页面提前加载好落地页的资源，然后在落地页实现秒开。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>如果命中NSR，fcp、tti等性能指标都会有较大提升</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对场景要求严格，需要落地页有较高的转化率，因为需要前置加载资源，低转化率会造成大量不必要的服务端压力。</li><li>开发限制，浏览器端特定的代码只能在某些生命周期钩子中使用。</li><li>需要前置页面停留时长较长，前置页面停留时长过短会直接降低NSR命中率，降级后NSR反而会影响目标页面性能。</li><li>依赖端内SDK</li></ul><h2 id="SSR-x2F-Streaming-SSR-x2F-SSG"><a href="#SSR-x2F-Streaming-SSR-x2F-SSG" class="headerlink" title="SSR &#x2F; Streaming SSR &#x2F; SSG"></a>SSR &#x2F; Streaming SSR &#x2F; SSG</h2><blockquote><p>SSR，是 “Server Side Rendering” 的缩写，即服务端渲染。SSR 的运行流程是服务端完成静态 HTML 内容的生成，并直接返回给浏览器，这些静态 HTML 的内容需要经过 hydration 后才能进行用户交互。</p></blockquote><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>不依赖端内SDK</li><li>命中SSR，fcp、tti等性能指标都会有较大提升</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>改造成本高，如果是新项目还好，老项目迁移成本太高了</li><li>维护成本相对较高，对于不了解SSR的同学来说，维护SSR项目可能会有一定成本。</li></ul><p><strong>考虑到该项目的跳转入口较多，并不依赖前置页面，且无端外场景的强诉求，我们最终还是决定使用Snapshot</strong>。</p><h1 id="落地"><a href="#落地" class="headerlink" title="落地"></a>落地</h1><p>确定了技术方案，我们终于可以实施了，但是在实施前，我们还需要考虑一件事情：<strong>AB实验</strong>。<br><strong>公司能够稳定运行是靠业务支撑的，而做技术如果不为了业务服务，那也只是闭门造车而已。</strong><br>所以我们需要设计实验方案，验证性能优化对业务指标的提升。</p><h2 id="服务端实验or客户端实验"><a href="#服务端实验or客户端实验" class="headerlink" title="服务端实验or客户端实验"></a>服务端实验or客户端实验</h2><p>在似乎不应该是一个取舍难题，但他确实让我权衡了很久，如果使用服务端实验，团队内部已经有较好的实践，至少在开实验这里，我可以毫不费力的解决这件事情。<br>但是这是一个纯前端的技术方案，如果使用服务端实验会造成曝光不准的情况，简单的说就是所有用户都会被分流，所有用户都会被纳入实验结果的统计中，这将导致实验结果不置信。<br>客户端实验可以实现精准曝光，但客户端实验都是由客户端同学主导的，让客户端同学配合自己做这件事情显然不太现实，毕竟这对他们来说是一件毫无收益的事情，所以如何让前端同学自己主导客户端实验就成了一个问题。</p><p><strong>既然没有统一的方案，那我们就制定方案</strong>，具体方案就是和客户端对齐实验流程，升级JSB，使前端有统一的方式去获取实验数据。</p><h2 id="如何应用实验组和对照组"><a href="#如何应用实验组和对照组" class="headerlink" title="如何应用实验组和对照组"></a>如何应用实验组和对照组</h2><p>snapshot的开关是配置化的，而获取实验结果的时机是在js执行阶段，我们显然无法通过配置的手段控制snapshot的开关。所以只能通过是否使用snapshot的api来控制开关。</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>其实不管是否使用snapshot，任何方案都需要考虑降级，snapshot的降级是很容易做的，因为任何原因所导致的降级都无法正常使用snapshot的api，所以我们只需要保留历史的骨架屏即可。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>其实在整个过程中，最困难的不是技术方案的调研和如何敲代码，而是将资源聚合在自己这里。<br>snapshot的运行需要公司内部sdk的支持，但是我们的APP IOS侧并未全量接入这个sdk，在我最开始做这件事情的时候，我得到的消息是&gt;&#x3D;778就可以使用这个sdk了，但实际上，当我把方案在安卓端跑通，但死活在IOS上跑不通时，我才知道原来这个sdk的开关是由另一条业务线的实验控制的。</p><p>现在想起来，其实这才是我遇到的最大困难，因为ios侧即使开启了SDK，但是snapshot也跑不通，我需要IOS同学与SDK侧的同学帮我调试。<br>让其他业务线的不同职能帮助我与第三方SDK同学调试，这基本上不可能，对于其他业务线的同学而言，他们应该会想：滚，别来沾边。</p><p>这使得项目被卡住，这也让我意识到一点：<strong>如果我不能将研发资源聚合在自己业务里，那这件事情一定会失败。</strong><br>这里涉及很多个点：</p><ul><li>方案顺利落地：只有研发资源在自己业务线，方案才能继续推动</li><li>风险控制：风险控制应该已业务线为维度，我们不该依赖其他业务线，我们需要自己开实验控制SDK</li><li>命中率：如果其他业务线的实验未带来收益而导致实验关闭，那我们业务的ios用户将都无法命中方案</li></ul><p><strong>所以，为了保证项目顺利推进，我向我们业务测的客户端同学提出了技术需求，走正式的需求排期，同时也有测试接入，让整个项目的流程规范起来。</strong></p><h2 id="数据消费"><a href="#数据消费" class="headerlink" title="数据消费"></a>数据消费</h2><p>解决了上面的所有问题，我们该考虑数据消费了，公司有统一的数据消费平台，只是自动上报的性能指标并不能满足诉求。我们希望可以以最直观的方式看到实验组&amp;对照组带来的差异。<br>通常情况下，数据消费平台都会有两个基础而又核心的部分：<strong>指标&amp;维度</strong>，就像是一张表的横轴和纵轴。<br>在这个case里，指标是pct75分位fcp，维度是实验组&amp;对照组，数据消费平台当然不知道我们的维度是什么，所以我们需要手动上报性能指标，同时带上我们需要的维度。</p><p>除了性能指标，我们还需要关注snapshot命中率，SDK命中率。<br>因为不确定项目对实际用户的影响，所以在设计实验的时候也比较保守，最开始实验组&amp;对照组只各开了25%，然后逐渐放量到50%，等拿到业务收益后再推全实验组。<br><strong>这样做不仅可以控制风险，还可以更好的分析数据是否符合预期。</strong></p><h1 id="产出-amp-收益"><a href="#产出-amp-收益" class="headerlink" title="产出&amp;收益"></a>产出&amp;收益</h1><ul><li>整理snapshot接入文档</li><li>整理SDK使用文档</li><li>整理客户端AB实验规范</li></ul><h2 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h2><p><img src="/images/optimize/1.jpeg"><br>可以看到，在一定程度上，实验组99分位的速度比对照组75分位还要快，这个提升已经非常明显了。</p><p>然而单用fcp这样的指标并不能很好的衡量页面性能，比如在这个case里，使用snapshot并不能提升TTI，snapshot只是前置了页面展现时间，而TTI还是依赖接口速度。所以这时候我们应该考虑使用<strong>离线化</strong>方案，当然我们也确实接入了离线化方案。</p><blockquote><p>可交互时间 (TTI) 是测量加载响应度的重要实验室指标。该指标有助于识别看起来具备交互性但实际上并非如此的页面情况。迅捷的 TTI 有助于确保页面的有效性。 引用自 <a href="https://web.dev/tti">https://web.dev/tti</a></p></blockquote><p>离线化方案的优化维度和传统h5不一样，传统h5的优化无非就是代码的调整和资源的前置、加速等，但是再快的下载速度都比不上直接读取本地文件快。</p><h2 id="业务指标"><a href="#业务指标" class="headerlink" title="业务指标"></a>业务指标</h2><p>我们分析了线索UV、留资率、页面回访&amp;停留时长，指标均为正向。</p><p>关于性能优化对于业务指标的影响，首先你要相信，性能优化带来的收益最终一定会反应到业务收益上，如果没有，<strong>那就是性能优化的幅度不够</strong>。<br>举个例子，当前页面FCP是1000ms，然后你从1000优化到700，业务数据并没有提升，但当你优化到400的时候，就会有用户觉得，这个页面变得好快啊，而正是这一点的心理反应，可能引起他们的积极情绪和认知反应，从而业务数据就会提升。</p><h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p>做到这里，这件事基本上就算是做完了，不过仔细想想，真的做完了吗？其实没有，作为一个技术专项，我们应该沉淀一套开箱即用的SDK，而不只是提供接入文档。<br>只是SDK的现状并不是那么稳定，我们需要考虑很多个点：</p><ul><li>是否有必要开箱即用？因为即便可以开箱即用，业务方还是需要根据业务诉求去定制快照</li><li>iOS sdk不稳定的原因是什么？</li><li>配置是否可以收敛到业务测？</li><li>配置流程是否可以自动化？</li><li>Snapshot的配置是否可以收敛到脚手架？</li><li>除此之外我们需要提供一个通用的snapshot的SDK</li></ul><p>而想要解决这些问题，那又可以开一个专项了，至少对于这个页面的性能优化而言，我觉得已经可以了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这不仅让我想起学生时代准备面试时，有一道经典问题：聊聊性能优化。那时我肯定会和面试官聊webpack构建性能、传输性能，然后再讲讲网络层面，讲讲CDN啥的。现在想想，有点好笑。工作几年后才切实的明白，<strong>性能优化这个事情一定是case by case的，不同环境，不同场景的不同技术方案都会有不同的优化方案，没有一成不变的方案，尤其越是上层的优化，就越不成定式，就越要和业务结合在一起。</strong></p><p>这篇文档记录的东西，我可能这辈子再也用不到了，他甚至不算一篇技术文档，因为一行代码都没有，但最重要的是如何思考和如何从0到1做事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理一些特殊场景的第三方库</title>
      <link href="/2023/08/08/package/"/>
      <url>/2023/08/08/package/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>整理一些工作中遇到的特殊场景会用到的开源库，大部分都比较基础，可能一辈子都用不上，但是还是得心里有个数。</p><h4 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h4><p><a href="https://virtuoso.dev/">Virtuoso</a></p><p>虚拟滚动的场景在工作中并不常见，就算见到也不好直接手写，用开源的库会好一些，通常情况下，可以封装成一个通用的基础组件。</p><h4 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h4><p><a href="https://ahooks.js.org/zh-CN/">aHooks</a></p><p>开源好用的hook库，这个还是比较常用的。</p><h4 id="H5表单"><a href="#H5表单" class="headerlink" title="H5表单"></a>H5表单</h4><p><a href="https://field-form-react-component.vercel.app/">rc-field-form</a></p><p>封装基础Form组件会用到</p><h4 id="WEB-3D"><a href="#WEB-3D" class="headerlink" title="WEB 3D"></a>WEB 3D</h4><p><a href="https://www.babylonjs.com/">Babylon</a></p><p>基于webgl的3d渲染引擎，值得学习。</p><h4 id="移动端拖拽-amp-动画"><a href="#移动端拖拽-amp-动画" class="headerlink" title="移动端拖拽&amp;动画"></a>移动端拖拽&amp;动画</h4><p><a href="https://use-gesture.netlify.app/">@use-gesture&#x2F;react</a></p><p><a href="https://www.react-spring.dev/">@react-spring&#x2F;web</a></p><p>这俩兄弟相辅相成，可以做很多移动端的拖拽动画效果，比如下拉刷新。</p><h4 id="文件操作相关"><a href="#文件操作相关" class="headerlink" title="文件操作相关"></a>文件操作相关</h4><p>find-up  寻找当前目录下的文件</p><p>fs-extra 文件读写</p><p>comment-json 更好的处理json文件</p><p>path 路径处理</p><p>prettier 格式化文件</p><h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><p><a href="https://driverjs.com/">driver.js</a></p><p>h5预览高亮dom会用到，或者一些新手引导会用到</p><h4 id="性能监测"><a href="#性能监测" class="headerlink" title="性能监测"></a>性能监测</h4><p><a href="https://www.npmjs.com/package/web-vitals">web-vitals</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是如何使用自己的mac的</title>
      <link href="/2023/06/25/mac/"/>
      <url>/2023/06/25/mac/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><p>这里是一些我经常会使用的软件。</p><h2 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h2><p><strong>我愿称其为浏览器前进路上的里程碑！</strong>作为一款浏览器，他真的太牛逼了，arc提出了新的理念，彻底的改变了我的工作流。<br>arc官方是这么形容他的</p><blockquote><p>Arc is the Chrome replacement I’ve been waiting for.</p></blockquote><ul><li>不再拥挤的tab</li><li>多space</li><li>高颜值</li><li>高适配</li><li>分屏、max等多个能力</li></ul><p>我的首推办公软件，也将成为我唯一的浏览器方案！<br><a href="https://arc.net/">arc官网</a></p><h2 id="hammerspoon"><a href="#hammerspoon" class="headerlink" title="hammerspoon"></a>hammerspoon</h2><p>这是目前为止我最喜欢用的一款效率办公软件之一，<strong>核心功能是为mac绑定各种快捷键，减少鼠标操作</strong>，从而提升工作效率。除了快速的打开应用，hammerspoon还可以通过键盘来操控窗口的大小和位置，鼠标定位等，可以让用户随意搭建自己喜欢的工作流，在这个过程中，完全不需要鼠标的参与。比如自从我开始使用hammerspoon后，就再也没有用过mac的全屏功能，虽然滑动切屏很有趣，但我更喜欢直接打开。</p><p>hammerspoon的本质是提供了系统api的桥接层，用户可以通过编写<code>lua</code>脚本来做很多系统层面的事情，当然，社区提供了大量有趣的配置文件，我们可以直接使用，我个人比较喜欢<code>awesome-hammerspoon</code>。</p><p><a href="https://github.com/Hammerspoon/hammerspoon/releases/tag/0.9.93">hammerspoon</a></p><p><a href="https://github.com/ashfinal/awesome-hammerspoon">awesome-hammerspoon配置文件</a></p><h2 id="ITerm2-amp-oh-my-zsh"><a href="#ITerm2-amp-oh-my-zsh" class="headerlink" title="ITerm2 &amp; oh-my-zsh"></a>ITerm2 &amp; oh-my-zsh</h2><p>想必每个程序员都会使用的默认终端替代方案。可以在官网自行下载，这里也搬运一下。</p><p><a href="https://iterm2.com/downloads.html">iterm2</a></p><p>oh-my-zsh下载方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;$(curl -fsSLhttps://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span></span><br></pre></td></tr></table></figure><p>on-my-zsh有很多的主题可选，我最喜欢的是<code>fino-time</code>，很好看。同时，iterm2也可以设置一些启动的快捷键，比如我的快捷键是<code>option + .</code>，通常情况下，我会开启多个终端管理我的所有项目。</p><h2 id="utools"><a href="#utools" class="headerlink" title="utools"></a>utools</h2><p>强大的插件生态，可以轻松的支持各种办公诉求，是mac自带的聚焦搜索的升级款。</p><p>通常情况下，我会用他打开一些系统软件，比如网络、设置等，因为其他应用软件的打开方式都被hammerspoon绑定了，utools刚好可以查漏补缺。其次，我通常会使用utools进行翻译，utools自带的翻译支持百度、有道、腾讯翻译等，非常方便。</p><p>除此之外，utools市场拥有大量的插件，比如OCR、计算器、chatgpt、还可以轻松查阅各种语言的文档，还有很多有用或没用的插件，十分有趣。</p><p>最后utools也支持一键唤出，默认是<code>option + space</code>，使用起来非常丝滑。</p><p><a href="https://www.u.tools/">utools官网</a></p><h2 id="nvm-amp-fnm"><a href="#nvm-amp-fnm" class="headerlink" title="nvm &amp; fnm"></a>nvm &amp; fnm</h2><p>每个学前端的都应该知道的node版本管理工具。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一键安装</span></span><br><span class="line">curl -o-<span class="attr">https</span>:<span class="comment">//raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh| bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .zshrc中添加环境变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">NVM_DIR</span>=<span class="string">&quot;$HOME/.nvm&quot;</span> </span><br><span class="line">[ -s <span class="string">&quot;$NVM_DIR/nvm.sh&quot;</span> ] &amp;&amp; . <span class="string">&quot;$NVM_DIR/nvm.sh&quot;</span> </span><br></pre></td></tr></table></figure><p>不过现在nvm其实有点过时了，<strong>现在比较推介fnm</strong>，nvm是用<code>Bash</code>脚本语言编写的，而fnm是用<code>Rust</code>编写的，懂的都懂。</p><blockquote><p>fnm 通过 Rust 语言提供了更快的安装和版本切换速度，并使用静态编译的方式打包二进制文件，因此不需要安装任何其他依赖项。此外，Rust 还提供了内存安全性和线程安全性，这使得 fnm 更加可靠和安全。</p></blockquote><p>使用fnm后，开启新终端时就不用等2s了，每次加载nvm的配置文件都很慢，<code>Rust</code>yyds</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装rust环境 装过的就不用再装了</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1<span class="number">.2</span> -sSf <span class="attr">https</span>:<span class="comment">//sh.rustup.rs | sh  </span></span><br><span class="line"><span class="comment">// 下载fnm</span></span><br><span class="line">curl -fsSL <span class="attr">https</span>:<span class="comment">//github.com/Schniz/fnm/raw/master/.ci/install.sh | bash -s -- --skip-shell</span></span><br><span class="line"><span class="comment">// .zshrc中设置环境变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span>=<span class="string">&quot;$HOME/.fnm:$PATH&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;$(fnm env)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Charles-amp-Proxyman"><a href="#Charles-amp-Proxyman" class="headerlink" title="Charles &amp; Proxyman"></a>Charles &amp; Proxyman</h2><p>在整理效率软件的时候我在想是否要把Charles写进来，因为严格意义上讲，Charles并不是一款效率软件，而是一款办公软件，之所以决定写进来是因为其实在一些大公司中，代理相关的工具一般不会使用Charles，而是倾向于集成在工程内部，这样不仅提升了办公效率，也对新同学更加友好，而带来的问题就是对新同学过于黑盒，一条命令行语句就能完成所有操作，反而导致出现问题后无从下手，无法排查问题。</p><p>所以我觉得，熟练使用一个第三方的代理工具，并且知道自己在做什么是非常重要的，这样即便脱离了工程化工具，也能轻松的做很多代理相关的事情，这也是一种效率吧。后续我会专门写一篇文章来讲一讲Charles的使用。</p><p>当然，Charles并不是唯一的代理方案，<strong>现在我可能会更推荐使用proxyman</strong>，听说性能比Charles好很多，还是很香的，以后可以考虑用一用。</p><p><a href="https://www.charlesproxy.com/">Charles官网</a></p><p><a href="https://proxyman.io/">Proxyman官网</a></p><h1 id="Chrome插件"><a href="#Chrome插件" class="headerlink" title="Chrome插件"></a>Chrome插件</h1><p>这里是一些我常用的Chrome插件。</p><h2 id="Proxy-SwitchyOmega"><a href="#Proxy-SwitchyOmega" class="headerlink" title="Proxy SwitchyOmega"></a>Proxy SwitchyOmega</h2><p><strong>一键切换是否需要系统代理。</strong>小工具，大作用，当我们不希望当前浏览的页面被系统级别的代理所代理时，这个插件可以帮助我们完成快速切换，非常方便。</p><h2 id="ModHeader-amp-Requestly"><a href="#ModHeader-amp-Requestly" class="headerlink" title="ModHeader &amp; Requestly"></a>ModHeader &amp; Requestly</h2><p>ModHeader是几乎每位参与开发Web应用的互联网人都会使用的插件，可以<strong>轻松快捷的添加、修改请求头、响应头。</strong>在使用泳道模式进行开发测试的今天，这样的小工具会非常方便，虽说代理工具也可以完成这个插件的所有工作，但在浏览器中快速的启动难道不是更香吗？</p><p>ModHeader最大的问题就是，不能为规则命名，通常情况下我们会添加多条规则，其实很麻烦，并且同时开发多个项目时，容易不知道哪个规则对应哪个。Requestly解决了这个问题，<strong>Requestly提供了更加规范、更加体系化的功能，可以使用户更加清晰明确的管理自己的规则</strong>，很好用。</p><h2 id="Vimium"><a href="#Vimium" class="headerlink" title="Vimium"></a>Vimium</h2><p><strong>在浏览器中使用vim的操作处理一切！</strong>是不是很酷，然而vim的上手成本较高，在提效前会有很长很长一段蛋疼的时间。其实我自己也并不熟练，但是翻页什么的还是可以用用的哈哈。</p><h2 id="沙拉滑词"><a href="#沙拉滑词" class="headerlink" title="沙拉滑词"></a>沙拉滑词</h2><p>非常轻量方便的翻译工具，不认识的单词，只要一划就能拿到翻译，比起调起翻译软件要方便许多。</p><h1 id="VSCode插件"><a href="#VSCode插件" class="headerlink" title="VSCode插件"></a>VSCode插件</h1><p>这里是一些我常用的VSCode插件。</p><h2 id="Project-Manager"><a href="#Project-Manager" class="headerlink" title="Project Manager"></a>Project Manager</h2><p>通常情况下，我们在开发中需要频繁的切换项目，这时候可能会打开很多个编辑器，容易手忙脚乱，这个插件可以让我们<strong>在一个编辑器中切换项目</strong>，非常方便。同时，project Manger提供了快捷键，可以使开发者不用鼠标就能实现在一个编辑器中切换项目，非常好使。</p><h2 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h2><p>这个插件在多人合作的开发模式中非常好使，<strong>你可以轻松方便的看到每一行代码最近的commit记录，包括时间和提交者</strong>，这非常有用，在排查问题的时候可以帮助你快速排查是否是线上问题。同时，该插件也提供了一些ui工具，比如可以方便的查看不同代码版本的diff等，非常好使。</p><h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><p><code>oh-my-zsh</code>提供了大量的<code>git</code>简化命令，说真的，如果不使用这些命令，每次敲完整的<code>git</code>命令都很麻烦，通常情况下，我会总是使用这些简化命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gaa <span class="comment">// git add .</span></span><br><span class="line">gcmsg <span class="comment">// git commit -m</span></span><br><span class="line">gp <span class="comment">// git push</span></span><br><span class="line">gm <span class="comment">// git merge</span></span><br><span class="line">gcm <span class="comment">// git checkout master</span></span><br><span class="line">gcb <span class="comment">// git checkout -b</span></span><br><span class="line">gloga <span class="comment">// git log --oneline --decorate --graph --all</span></span><br></pre></td></tr></table></figure><p>除了这些我经常会使用的命令，其余快捷指令可以在<a href="https://kapeli.com/cheat_sheets/Oh-My-Zsh_Git.docset/Contents/Resources/Documents/index">这里</a>看到。</p><p>这些快捷指令不能覆盖所有场景，我们也可以通过修改.zshrc文件来设置<code>git</code>快捷指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias gs=<span class="string">&#x27;git switch&#x27;</span></span><br><span class="line">alias gc-=<span class="string">&#x27;git checkout -&#x27;</span></span><br><span class="line">alias gpl=<span class="string">&#x27;git pull&#x27;</span></span><br></pre></td></tr></table></figure><p>然后我就可以通过<code>gs</code>和<code>gc-</code>来快速的切换分支和返回上一个分支，用<code>gpl</code>拉代码，非常方便。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>当我们开始使用一个新的界面或工具时，需要花费一些时间来适应新的工具，在这个过程中，我们可能会因为不熟悉工具使用而导致效率降低。随着我们逐渐熟悉这些工具，他们的效率会逐渐提高，并且在一定阈值后达到峰值。在这个峰值之后，我们的效率可能会因为工具数量过多而下降，导致工具提示临界负载的情况。</p><p>所以合理使用工具，使用适量的工具，使用适合自己的工具。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客</title>
      <link href="/2023/06/12/blog/"/>
      <url>/2023/06/12/blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h1><p>坦白的讲，这是我的第五次做博客了，为啥会有这么多个呢？</p><p>早在大二那会，我就想搞个博客了，我一直觉得，如果有一天能有自己的网站，那一定是一件很酷的事情，所以在大二那会，我就开始搞了。</p><p>似乎每个学计算机的都会搞一个博客，我也不例外，第一个博客用最基本的前端三件套：<code>html</code>、<code>css</code>和<code>js</code>，没有任何组件库，纯手写，<code>mysql</code>存数据，然后用<code>node</code>搭了一个简单的服务器就完事了。现在想想其实挺佩服那时的自己的，毕竟纯手写是真的勇士。</p><p>但第一个博客并没有投入使用，因为我的热情在我手撸完所有代码后就已经消散殆尽了，我开始嫌弃丑的一批的ui，开始嫌弃简陋不堪的功能，似乎一切只是为了满足最开始的那个幻想。</p><p>于是我就有了第二个博客。</p><p>第二次我学聪明了，开始使用各种工具库、组件库。但是聪明不了一点，还是纯手撸啊喂！</p><p>为了客制化markdown效果，我有了自己的第三个博客，不过这个博客半路夭折了，因为工作量实在是太大了，光是搭建后台就已经花费了我太多精力，不过客制化的效果我很满意，毕竟是自己的东西，我想怎么写怎么写。</p><p><img src="/images/blog.jpeg"></p><p>有了前三次的经历，我不禁开始思考：<strong>我为什么要做这件事情？我的初衷是什么？</strong> 其实我大概只是想要个能写些什么的，然后属于自己的小天地吧。但是为了这个小天地，我花了大量时间造轮子，用别人造好的轮子造轮子，而我造的轮子还没别人的好，我应该把精力放在输出上，而不是死在输出的路上。</p><p>于是我开始关注<code>D2C</code>、<code>low code</code>相关方案，第四个博客其实只是一个试验品，于是这个博客就诞生了。</p><p>有了前几次的经验，这次我清楚的知道自己想要什么，什么功能是必须要有的，什么功能是无所谓的。至于样式这里，其实我一直都想做的尽可能的花里胡哨，但到头来还是返璞归真，觉得简单的东西才是最好的。</p><p>最后呢，这个博客还有很多需要优化调整的点，我会慢慢补齐。我会在这里记录我的生活，工作，和一些乱七八糟的事情。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
